/// <reference lib="webworker" />
/* eslint-disable @typescript-eslint/no-unused-vars */

// Define missing event types
interface SyncEvent extends Event {
  readonly tag: string
  waitUntil(promise: Promise<unknown>): void
}

interface PeriodicSyncEvent extends Event {
  readonly tag: string
  waitUntil(promise: Promise<unknown>): void
}
import { clientsClaim } from "workbox-core"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies"
import { ExpirationPlugin } from "workbox-expiration"
import { CacheableResponsePlugin } from "workbox-cacheable-response"

declare const self: ServiceWorkerGlobalScope

// Use clientsClaim to take control immediately
clientsClaim()

// Precache all assets generated by the build process
const manifest = self.__WB_MANIFEST
precacheAndRoute(manifest)

// Cache the index.html page and return it for all navigation requests
const indexHandler = createHandlerBoundToURL("/index.html")
registerRoute(({ request }) => request.mode === "navigate", indexHandler)

// Cache CSS, JS, and Web Worker files with a Stale While Revalidate strategy
registerRoute(
  ({ request }) =>
    request.destination === "style" ||
    request.destination === "script" ||
    request.destination === "worker",
  new StaleWhileRevalidate({
    cacheName: "assets-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// Cache images with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "images-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// Cache font files with a Cache First strategy
registerRoute(
  ({ request }) => request.destination === "font",
  new CacheFirst({
    cacheName: "fonts-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
)

// Handle offline fallback
const offlineFallbackPage = "/offline.html"

// Cache the offline page on install
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open("offline-cache").then((cache) => {
      return cache.add(offlineFallbackPage)
    })
  )
})

// Serve the offline page when offline and the requested page is not in cache
self.addEventListener("fetch", (event) => {
  if (event.request.mode === "navigate") {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(offlineFallbackPage).then((response) => {
          return (
            response ||
            new Response("Offline page not found", {
              status: 503,
              statusText: "Service Unavailable",
            })
          )
        })
      })
    )
  }
})

// Listen for messages from the client
self.addEventListener("message", (event: ExtendableMessageEvent) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting()
  }

  // Handle simulation messages
  if (event.data && event.data.type === "SIMULATION_UPDATE") {
    // Update any UI or state as needed
    self.clients
      .matchAll({
        type: "window",
        includeUncontrolled: true,
      })
      .then((clients) => {
        clients.forEach((client) => {
          client.postMessage({
            type: "SIMULATION_UPDATE",
            data: event.data.data,
          })
        })
      })
  }
})

// Background sync for offline actions
self.addEventListener("sync", ((event: Event) => {
  const syncEvent = event as SyncEvent
  if (syncEvent.tag === "sync-history") {
    syncEvent.waitUntil(syncHistory())
  }
}) as EventListener)

// Function to sync history data when coming back online
async function syncHistory() {
  try {
    // This would typically sync with a server
    // For this app, we're just ensuring local storage is consistent
    const historyData = localStorage.getItem("numberHistory")
    if (historyData) {
      // In a real app, you might send this data to a server
      // Notify clients that history has been synced
      const clients = await self.clients.matchAll({ type: "window" })
      clients.forEach((client) => {
        client.postMessage({
          type: "HISTORY_SYNCED",
          success: true,
        })
      })
    }
    return Promise.resolve()
  } catch (error) {
    // Notify clients of the error
    const clients = await self.clients.matchAll({ type: "window" })
    clients.forEach((client) => {
      client.postMessage({
        type: "HISTORY_SYNCED",
        success: false,
        error: error instanceof Error ? error.message : String(error),
      })
    })
    return Promise.reject(error)
  }
}

// Periodic sync to keep data fresh (if supported)
self.addEventListener("periodicsync", ((event: Event) => {
  const periodicSyncEvent = event as PeriodicSyncEvent
  if (periodicSyncEvent.tag === "refresh-data") {
    periodicSyncEvent.waitUntil(refreshData())
  }
}) as EventListener)

// Function to refresh data periodically
async function refreshData() {
  try {
    // In a real app with a backend, you might fetch fresh data here
    return Promise.resolve()
  } catch (error) {
    return Promise.reject(error)
  }
}

// Handle notification clicks
self.addEventListener("notificationclick", (event: NotificationEvent) => {
  const notification = event.notification
  const action = event.action
  const data = notification.data as { url?: string } | undefined

  // Close the notification
  notification.close()

  // Handle different actions
  if (action === "open") {
    // Open the app
    if (data && data.url) {
      event.waitUntil(
        (async () => {
          const clientList = await self.clients.matchAll({ type: "window" })
          // Check if there is already a window/tab open with the target URL
          for (const client of clientList) {
            if (client.url === data.url && "focus" in client) {
              return (client as WindowClient).focus()
            }
          }
          // If no window/tab is open, open a new one
          if (self.clients.openWindow && data.url) {
            return self.clients.openWindow(data.url)
          }
          return undefined
        })()
      )
    }
  }

  // If no action or default action, just open the app
  if (!action || action === "default") {
    event.waitUntil(
      (async () => {
        const clientList = await self.clients.matchAll({ type: "window" })
        for (const client of clientList) {
          if ("focus" in client) {
            return (client as WindowClient).focus()
          }
        }
        if (self.clients.openWindow) {
          return self.clients.openWindow("/")
        }
        return undefined
      })()
    )
  }
})
